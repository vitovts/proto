#VIM

- Поиск

/word 	Искать слово “word” сверху вниз

?word 	Искать слово “word” снизу вверх

/jo[ha]n> 	Искать “john” или “joan”

/\< the 	Искать слова, начинающееся на “the”

/the\> 	Искать слова, заканчивающиеся на “the”

/\< the\> 	Искать “the” (точное соответствие)

/\< …. \> 	Искать слова из четырех символов

/fred\|joe 	Искать “fred” или “joe”

/\<\d\d\d\d\> 	Искать 4 цифры подряд

/^\n\{3} 	Искать 3 пустые строки

:bufdo /searchstr/ 	Искать во всех открытых файлах

- Удаление

d^ 	Удалить все символы от текущей позиции до начала строки

d$ 	Удалить все символы от текущей позиции до конца строки

d/word 	Удалить всё от текущей позиции до слова "word"

dfx 	Удалить всё от текущей позиции до символа "x"

- Замена

:%s/old/new/g 	Заменить все вхождения “old” на “new”

:%s/old/new/gw 	Заменить все вхождения “old” на “new” с запросом подтверждения

:2,35s/old/new/g 	Заменить все вхождения “old” на “new” между 2 и 35 строками

:5,$s/old/new/g 	Заменить все вхождения “old” на “new” начиная с 5 строки и до конца файла

:%s/^/hello/g 	Добавить “hello” в начало каждой строки

:%s/$/Harry/g 	Добавить “Harry” в конец каждой строки

:%s/onward/forward/gi 	Заменить “onward” на “forward” с учетом регистра

:%s/ *$//g 	Убрать все пробелы

:g/string/d 	Удалить все строки, содержащие “string”

:v/string/d 	Удалить все строки, не содержащие “string”

:s/Bill/Steve/ 	Заменить первое вхождение “Bill” на “Steve” в текущей строке

:s/Bill/Steve/g 	Заменить все вхождения “Bill” на “Steve” в текущей строке

:%s/\r//g 	Убрать символ возврата каретки (Такие тексты обычно приходят от windows-пользователей)

:%s#>[^<]\+>##g 	Очистить текст от HTML-тегов

:%s/^\(.*\)\n\1$/\1/ 	Удалить строки, повторяющиеся дважды

Ctrl+a 	Увеличить число под курсором на единицу

Ctrl+x 	Уменьшить число под курсором на единицу

ggVGg? 	Преобразовать текст в Rot13

Комментарий к замене: ...мне нужно во всем файле совершить замену

Abs[ 'выражение' ] -> | 'выражение' |

Если при описании разыскиваемой последовательности заключить какое-нибудь выражение в скобки \( \), то Vim поместит его в память под соответствующим номером (первое выражение под номером один, второе — два) и позволит в дальнейшем вызывать командой \x, где x — номер, под которым выражение было помещено в память.

Таким образом, нужная команда будет выглядеть примерно так:

:%s/Abs\[\([^\]]*\)\]/|\1|/g

Здесь стоит отметить, что для буквального совпадения квадратные скобки предваряются слешами, поскольку являются спецсимволами. Вообще любой спецсимвол, если должен участвовать в поиске, обозначая свое непосредственное значение, предваряется слешем: \^; \* и т.д. Сам слеш предваряется также слешем. Выглядит это так: для поиска последовательности '\cos' надо ввести '\\cos'.

...совершить замену вида

'Заглавная латинская буква''цифра' -> 'Заглавная латинская буква'_'цифра'

Самое тривиальное решение, которое напрашивается — перебрать все комбинации, если их немного. То есть, запустить замену сначала 'U1' -> 'U_1', потом 'U2' -> 'U_2' и т.п. Понятно, что это не наш метод. Мы вспомним, что есть квадратные скобки. И для того, чтобы найти одну заглавную латинскую букву, достаточно ввести шаблон '[A-Z]'. Но и это не предел. Для такого шаблона у Vim есть специальная аббревиатура: '\u' (от 'uppercase'). Для цифр же есть '\d' (от 'digit'). Подробнее о таких конструкциях можно почитать по адресу :help pattern.txt. С использованием этих аббревиатур команда для поиска примет вид

:%s/\(\u\)\(\d\)/\1_\2/g

Тут опять встречается группировка круглыми скобками: она позволяет при поиске поместить найденную букву и цифру в память под соотвествующими номерами, и впоследствии их оттуда извлечь, вызывая командами с теми же номерами: '\1' вызовет букву, а '\2' — цифру.

Регистр

Vu 	Перевести строку в нижний регистр

VU 	Перевести строку в верхний регистр

g~~ 	Инвертировать регистр

vEU 	Перевести слово под курсором в верхний регистр

vE~ 	Инвертировать регистр слова

ggguG 	Перевести весь текст в нижний регистр

:set ignorecase 	Регистронезависимый поиск

:set smartcase 	Игнорировать регистр при поиске, если в искомом выражении нет символов верхнего регистра

:%s/\<./\u&/g 	Перевести первую букву каждого слова в верхний регистр

:%s/\<./\l&/g 	Перевести первую букву каждого слова в нижний регистр

:%s/.*/\u& 	Перевести первую букву первого слова в каждой строке в верхний регистр

:%s/.*/\l& 	Перевести первую букву первого слова в каждой строке в нижний регистр

- Чтение/запись файлов
:1,10 w outfile 	Записать в outfile с первой по десятую строки

:1,10 w >> outfile 	Добавить в outfile с первой по десятую строки

:r infile 	Вставить содержимое файла infile

:23r infile 	Вставить содержимое файла infile после 23 строки

- Навигация по ФС

:e . 	Открыть встроенный файл-менеджер

:Sex 	Разбить окно и открыть встроенный файл менеджер

:browse e 	Графический файл-менеджер

:ls 	Список буферов

:cd .. 	Перейти в родительскую директорию

:args 	Список открытых файлов

:args *.php 	Открыть все файлы с расширением *.php

:grep expression *.php 	Показать список файлов с расширением php, содержащих в имени expression

gf 	Открыть файл с именем, равным слову, находящемуся под курсором

- Взаимодействие с ОС

:!pwd 	Выполнить команду pwd и вернуться

!!pwd 	Выполнить команду pwd и вставить результат в редактор

:sh 	Открыть шелл

$exit 	Вернуться в редактор из шелла

- Выравнивание

:%!fmt 	Выровнять все строки

!}fmt 	Выровнять все строки в текущей позиции

5!!fmt 	Выровнять следующие 5 строк

- Вкладки

:tabnew 	Создать новую вкладку

gt 	Перейти на следующую вкладку

:tabfirst 	Перейти на первую вкладку

:tablast 	Перейти на последнюю вкладку

:tabm n(position) 	Изменить порядок вкладок

:tabdo %s/foo/bar/g 	Выполнить команду во всех вкладках

:tab ball 	Поместить все открытые файлы во вкладки

- Разделение окна

:e filename 	Редактировать filename в текущем окне

:split filename 	Разделить окно и открыть filename

ctrl-w + стрелка ВВЕРХ 	Переместить курсор в верхнее окно

ctrl-w ctrl-w 	Переместить курсор в следующее окно

ctrl-w ctrl-p 	Переместить курсор в предыдущее окно(вернуться назад)

ctrl-w ctrl-x 	Поменять окна местами

ctrl-w_ 	Максимизировать текущее окно

ctrl-w= 	Подогнать окна по размеру

10 ctrl-w+ 	Увеличить текущее окно на 10 строк

:vsplit file 	Вертикально разделить окно

:sview file 	Разделить окно и открыть file только для чтения

:hide 	Закрыть текущее окно

:only 	Закрыть все окна, кроме текущего

:b 2 	Открыть #2 в текущем окне

- Автодополнение

Ctrl+n Ctrl+p (в режиме вставки) 	Дополнить слово

Ctrl+x Ctrl+l 	Дополнить строку

:set dictionary=dict 	Установить словарь

Ctrl+x Ctrl+k 	Дополнение из словаря

- Метки

mk 	Пометить текущую позиция как k

‘k 	Перейти к метке k

d’k 	Удалить все до метки k

d’a,’k 	Удалить все от метки a до метки k

- Сокращения

:ab mail mail@provider.org 	Определить mail как сокращение от mail@provider.org

- Отступы

:set autoindent 	Включить автоматическую расстановку отступов

:set smartindent 	Включить “умную” расстановку отступов

:set shiftwidth=4 	Установить отступ равный 4 пробелам

ctrl-t, ctrl-d 	Убрать/добавить отступ в режиме вставки

<< 	Добавить отступ

>> 	Убрать отступ

- Подсветка синтаксиса

:syntax on 	Включить подсветку

:syntax off 	Выключить подсветку

:set syntax=perl 	Установить режим подсветки


Вставить  символ в начало большого количества подряд идущих строк:

Вариант 1


    Use Ctrl+v to select the first column of text in the lines you want to comment.

    Then hit 'I' and type the text you want to insert.

    Then hit 'Esc', wait 1 second and the inserted text will appear on every line.

Вариант 2

This replaces the beginning of each line with "//":

:%s!^!//!


This replaces the beginning of each selected line (use visual mode to select) with "//":

:'<,'>s!^!//! 


---
What if you’ve forgot to give sudo when you’ve opened the /etc/group file as shown below? In this case, instead of coming out of the file (and loosing all your changes) and executing the vim command with sudo, you can do the following.


$ vim /etc/group

:w !sudo tee %



Note: “:w !sudo tee %” will save the file as root privilege, even if you didn’t use sudo command to open it.
---
Использование стиля “подсветил — посмотрел — выполнил” совместно с визуальным режимом оказалось очень удобной практикой. Такое комбинирование стилей выделения используется при решении задач типа “в данной функции переименовать переменную foo в bar” и подобных. Такая (и подобные) задачи решаются последовательностью действий:


    Подсвечиваем foo командой *

    Переходим в режим визуального выделения и выделяем текущую функцию

    Отдаем команду замены :’<,’>s//bar/g


Символы ’<,’>, означающие начало и конец текущего выделенного блока, и определяющие диапазон применения команды :s, Vim подставляет автоматически при отдаче любой команды из режима визуального выделения. Также опущен первый аргумент команды :s, т. к. набирать его нет необходимости — когда он опущен, Vim использует в качестве этого аргумента содержимое регистра текущего поиска. То есть именно то, что подсвечено желтым.

:g//t$ — скопировать строки, содержащие подсвеченное значение, в конец файла. Если, например, надо быстро понять, как глобальная переменная (sic! — а что делать, в legacy-коде они встречаются) используется в модуле.

:g//d — удалить строки, содержащие подсвеченное значение
:g!//d — удалить стрки, НЕ содержащие подсвеченного значения

Заменить каждое вхождение нескольких пустых строк на одну пустую строку (чтобы между параграфами стал одинаковый промежуток в одну линию):
:v/./,/./-j

Убрать пустые строки (в визуальном режиме)
:'<,'>g/^$/d

Раздвинуть подряд идущие строки (обратное предыдущему действие, каждая строка станет параграфом)
Нужно при форматировании текста под 76 символов, из формата, как его сохраняет Word, когда каждый абзац становится строкой в текстовом файле.
:'<,'>s/$/\r/g

быстро вставить текст при включенном autoindent (set ai)  - борьба с "лесенкой"
